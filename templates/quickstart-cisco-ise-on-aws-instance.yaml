AWSTemplateFormatVersion: 2010-09-09
Description: >-
  This template  deploys a cisco ise appliance in a VPC (qs-1sp7rithq)
Parameters:
  KeyPairName:
    Description: >-
      To access the Cisco ISE instance via SSH, choose the PEM file that you
      created in AWS for the username "admin". Create a PEM key pair in AWS now
      if you have not configured one already. Usage example:  ssh -i
      mykeypair.pem admin@myhostname.compute-1.amazonaws.com
    Type: 'AWS::EC2::KeyPair::KeyName'
    AllowedPattern: .+
    ConstraintDescription: Instance Key Pair cannot be empty
  ISEInstanceType:
    Type: String
    Description: Choose the required Cisco ISE instance type.
    Default: c5.4xlarge
    AllowedValues:
      - c5.4xlarge
      - m5.4xlarge
      - c5.9xlarge
      - t3.xlarge
    ConstraintDescription: Instance type should be one of the allowed values
  EBSEncrypt:
    Description: Choose true to enable EBS encryption.
    Type: String
    Default: 'false'
    AllowedValues:
      - 'false'
      - 'true'
    ConstraintDescription: It can either be true or false
  ERSapi:
    Description: Do you wish to enable ERS?
    Type: String
    Default: 'yes'
    AllowedValues:
      - 'yes'
      - 'no'
    ConstraintDescription: It can either be yes or no
  OpenAPI:
    Description: Do you wish to enable OpenAPI?
    Type: String
    Default: 'yes'
    AllowedValues:
      - 'yes'
      - 'no'
    ConstraintDescription: It can either be yes or no
  PXGrid:
    Description: Do you wish to enable pxGrid?
    Type: String
    Default: 'no'
    AllowedValues:
      - 'yes'
      - 'no'
    ConstraintDescription: It can either be yes or no
  PXGridCloud:
    Description: Do you wish to enable pxGrid Cloud?
    Type: String
    Default: 'no'
    AllowedValues:
      - 'yes'
      - 'no'
    ConstraintDescription: It can either be yes or no
  PrivateSubnet1A:
    Type: 'AWS::EC2::Subnet::Id'
    Description: >-
      ID of the subnet to be used for the ISE deployment  in an Availability Zone A.
  PrivateSubnet1B:
    Type: 'AWS::EC2::Subnet::Id'
    Description: >-
      ID of the subnet to be used for the ISE deployment  in an Availability Zone B.
  PrivateSubnet1CIDR:
    AllowedPattern: '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(1[6-9]|2[0-8]))$'
    ConstraintDescription: CIDR block parameter must be in the form x.x.x.x/16-28
    Default: 10.0.0.0/19
    Description: CIDR block for private subnet 1 located in Availability Zone 1.
    Type: String
  PrivateSubnet2CIDR:
    AllowedPattern: '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(1[6-9]|2[0-8]))$'
    ConstraintDescription: CIDR block parameter must be in the form x.x.x.x/16-28
    Default: 10.0.32.0/19
    Description: CIDR block for private subnet 2 located in Availability Zone 2.
    Type: String
  FailoverPollingRate:
    Description:
      The rate (frequency) that determines when CloudWatch Events runs the rule that
      triggers the Route Monitor Lambda function.
    Default: rate(60 minutes)
    AllowedValues:
      - rate(1 minute)
      - rate(10 minutes)
      - rate(60 minutes)
    Type: String

  HealthcheckPollingRate:
    Description:
      The rate (frequency) that determines when CloudWatch Events runs the rule that
      triggers the Route Monitor Lambda function.
    Default: rate(10 minutes)
    AllowedValues:
      - rate(1 minute)
      - rate(10 minutes)
      - rate(60 minutes)
    Type: String

  Node1Hostname:
    Description: >-
      Enter the hostname. This field only supports alphanumeric characters and
      hyphen (-). The length of the hostname should not exceed 19 characters.
    Type: String
    Default: iseserver1
    AllowedPattern: '^[a-zA-Z0-9-]{1,19}$'
    ConstraintDescription: >-
      This field only supports alphanumeric characters and hyphen (-). Hostname
      should not be more than 19 characters.
  Node2Hostname:
    Description: >-
      Enter the hostname. This field only supports alphanumeric characters and
      hyphen (-). The length of the hostname should not exceed 19 characters.
    Type: String
    Default: iseserver2
    AllowedPattern: '^[a-zA-Z0-9-]{1,19}$'
    ConstraintDescription: >-
      This field only supports alphanumeric characters and hyphen (-). Hostname
      should not be more than 19 characters.
  #User defined R53 Private Hosted zone domain name
  DNSDomain:
    Description: >-
      Enter a domain name in correct syntax (for example, cisco.com). The valid
      characters for this field are ASCII characters, numerals, hyphen (-), and
      period (.). If you use the wrong syntax, Cisco ISE services might not come
      up on launch.
    Type: String
    Default: example.com
    AllowedPattern: '^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9](?:\.[a-zA-Z]{2,})+$'
    ConstraintDescription: >-
      Cannot be an IP address. Valid characters include ASCII characters, any
      numerals, the hyphen (-), and the period (.) for DNS domain.
  TimeZone:
    Description: Choose a system time zone.
    Type: String
    Default: Etc/UTC
    AllowedValues:
      - Africa/Abidjan
      - Africa/Accra
      - Africa/Algiers
      - Africa/Bissau
      - Africa/Cairo
      - Africa/Casablanca
      - Africa/Ceuta
      - Africa/El_Aaiun
      - Africa/Johannesburg
      - Africa/Juba
      - Africa/Khartoum
      - Africa/Lagos
      - Africa/Maputo
      - Africa/Monrovia
      - Africa/Nairobi
      - Africa/Ndjamena
      - Africa/Sao_Tome
      - Africa/Tripoli
      - Africa/Tunis
      - Africa/Windhoek
      - America/Adak
      - America/Anchorage
      - America/Araguaina
      - America/Argentina/Buenos_Aires
      - America/Argentina/Catamarca
      - America/Argentina/Cordoba
      - America/Argentina/Jujuy
      - America/Argentina/La_Rioja
      - America/Argentina/Mendoza
      - America/Argentina/Rio_Gallegos
      - America/Argentina/Salta
      - America/Argentina/San_Juan
      - America/Argentina/San_Luis
      - America/Argentina/Tucuman
      - America/Argentina/Ushuaia
      - America/Asuncion
      - America/Atikokan
      - America/Bahia
      - America/Bahia_Banderas
      - America/Barbados
      - America/Belem
      - America/Belize
      - America/Blanc-Sablon
      - America/Boa_Vista
      - America/Bogota
      - America/Boise
      - America/Cambridge_Bay
      - America/Campo_Grande
      - America/Cancun
      - America/Caracas
      - America/Cayenne
      - America/Chicago
      - America/Chihuahua
      - America/Costa_Rica
      - America/Creston
      - America/Cuiaba
      - America/Curacao
      - America/Danmarkshavn
      - America/Dawson
      - America/Dawson_Creek
      - America/Denver
      - America/Detroit
      - America/Edmonton
      - America/Eirunepe
      - America/El_Salvador
      - America/Fort_Nelson
      - America/Fortaleza
      - America/Glace_Bay
      - America/Goose_Bay
      - America/Grand_Turk
      - America/Guatemala
      - America/Guayaquil
      - America/Guyana
      - America/Halifax
      - America/Havana
      - America/Hermosillo
      - America/Indiana/Indianapolis
      - America/Indiana/Knox
      - America/Indiana/Marengo
      - America/Indiana/Petersburg
      - America/Indiana/Tell_City
      - America/Indiana/Vevay
      - America/Indiana/Vincennes
      - America/Indiana/Winamac
      - America/Inuvik
      - America/Iqaluit
      - America/Jamaica
      - America/Juneau
      - America/Kentucky/Louisville
      - America/Kentucky/Monticello
      - America/La_Paz
      - America/Lima
      - America/Los_Angeles
      - America/Maceio
      - America/Managua
      - America/Manaus
      - America/Martinique
      - America/Matamoros
      - America/Mazatlan
      - America/Menominee
      - America/Merida
      - America/Metlakatla
      - America/Mexico_City
      - America/Miquelon
      - America/Moncton
      - America/Monterrey
      - America/Montevideo
      - America/Nassau
      - America/New_York
      - America/Nipigon
      - America/Nome
      - America/Noronha
      - America/North_Dakota/Beulah
      - America/North_Dakota/Center
      - America/North_Dakota/New_Salem
      - America/Nuuk
      - America/Ojinaga
      - America/Panama
      - America/Pangnirtung
      - America/Paramaribo
      - America/Phoenix
      - America/Port-au-Prince
      - America/Port_of_Spain
      - America/Porto_Velho
      - America/Puerto_Rico
      - America/Punta_Arenas
      - America/Rainy_River
      - America/Rankin_Inlet
      - America/Recife
      - America/Regina
      - America/Resolute
      - America/Rio_Branco
      - America/Santarem
      - America/Santiago
      - America/Santo_Domingo
      - America/Sao_Paulo
      - America/Scoresbysund
      - America/Sitka
      - America/St_Johns
      - America/Swift_Current
      - America/Tegucigalpa
      - America/Thule
      - America/Thunder_Bay
      - America/Tijuana
      - America/Toronto
      - America/Vancouver
      - America/Whitehorse
      - America/Winnipeg
      - America/Yakutat
      - America/Yellowknife
      - Antarctica/Casey
      - Antarctica/Davis
      - Antarctica/DumontDUrville
      - Antarctica/Macquarie
      - Antarctica/Mawson
      - Antarctica/Palmer
      - Antarctica/Rothera
      - Antarctica/Syowa
      - Antarctica/Troll
      - Antarctica/Vostok
      - Asia/Almaty
      - Asia/Amman
      - Asia/Anadyr
      - Asia/Aqtau
      - Asia/Aqtobe
      - Asia/Ashgabat
      - Asia/Atyrau
      - Asia/Baghdad
      - Asia/Baku
      - Asia/Bangkok
      - Asia/Barnaul
      - Asia/Beirut
      - Asia/Bishkek
      - Asia/Brunei
      - Asia/Chita
      - Asia/Choibalsan
      - Asia/Colombo
      - Asia/Damascus
      - Asia/Dhaka
      - Asia/Dili
      - Asia/Dubai
      - Asia/Dushanbe
      - Asia/Famagusta
      - Asia/Gaza
      - Asia/Hebron
      - Asia/Ho_Chi_Minh
      - Asia/Hong_Kong
      - Asia/Hovd
      - Asia/Irkutsk
      - Asia/Jakarta
      - Asia/Jayapura
      - Asia/Jerusalem
      - Asia/Kabul
      - Asia/Kamchatka
      - Asia/Karachi
      - Asia/Kathmandu
      - Asia/Khandyga
      - Asia/Kolkata
      - Asia/Krasnoyarsk
      - Asia/Kuala_Lumpur
      - Asia/Kuching
      - Asia/Macau
      - Asia/Magadan
      - Asia/Makassar
      - Asia/Manila
      - Asia/Nicosia
      - Asia/Novokuznetsk
      - Asia/Novosibirsk
      - Asia/Omsk
      - Asia/Oral
      - Asia/Pontianak
      - Asia/Pyongyang
      - Asia/Qatar
      - Asia/Qostanay
      - Asia/Qyzylorda
      - Asia/Riyadh
      - Asia/Sakhalin
      - Asia/Samarkand
      - Asia/Seoul
      - Asia/Shanghai
      - Asia/Singapore
      - Asia/Srednekolymsk
      - Asia/Taipei
      - Asia/Tashkent
      - Asia/Tbilisi
      - Asia/Tehran
      - Asia/Thimphu
      - Asia/Tokyo
      - Asia/Tomsk
      - Asia/Ulaanbaatar
      - Asia/Urumqi
      - Asia/Ust-Nera
      - Asia/Vladivostok
      - Asia/Yakutsk
      - Asia/Yangon
      - Asia/Yekaterinburg
      - Asia/Yerevan
      - Atlantic/Azores
      - Atlantic/Bermuda
      - Atlantic/Canary
      - Atlantic/Cape_Verde
      - Atlantic/Faroe
      - Atlantic/Madeira
      - Atlantic/Reykjavik
      - Atlantic/South_Georgia
      - Atlantic/Stanley
      - Australia/Adelaide
      - Australia/Brisbane
      - Australia/Broken_Hill
      - Australia/Darwin
      - Australia/Eucla
      - Australia/Hobart
      - Australia/Lindeman
      - Australia/Lord_Howe
      - Australia/Melbourne
      - Australia/Perth
      - Australia/Sydney
      - CET
      - CST6CDT
      - EET
      - EST
      - EST5EDT
      - Etc/GMT
      - Etc/GMT+1
      - Etc/GMT+10
      - Etc/GMT+11
      - Etc/GMT+12
      - Etc/GMT+2
      - Etc/GMT+3
      - Etc/GMT+4
      - Etc/GMT+5
      - Etc/GMT+6
      - Etc/GMT+7
      - Etc/GMT+8
      - Etc/GMT+9
      - Etc/GMT-1
      - Etc/GMT-10
      - Etc/GMT-11
      - Etc/GMT-12
      - Etc/GMT-13
      - Etc/GMT-14
      - Etc/GMT-2
      - Etc/GMT-3
      - Etc/GMT-4
      - Etc/GMT-5
      - Etc/GMT-6
      - Etc/GMT-7
      - Etc/GMT-8
      - Etc/GMT-9
      - Etc/UTC
      - Europe/Amsterdam
      - Europe/Andorra
      - Europe/Astrakhan
      - Europe/Athens
      - Europe/Belgrade
      - Europe/Berlin
      - Europe/Brussels
      - Europe/Bucharest
      - Europe/Budapest
      - Europe/Chisinau
      - Europe/Copenhagen
      - Europe/Dublin
      - Europe/Gibraltar
      - Europe/Helsinki
      - Europe/Istanbul
      - Europe/Kaliningrad
      - Europe/Kiev
      - Europe/Kirov
      - Europe/Lisbon
      - Europe/London
      - Europe/Luxembourg
      - Europe/Madrid
      - Europe/Malta
      - Europe/Minsk
      - Europe/Monaco
      - Europe/Moscow
      - Europe/Oslo
      - Europe/Paris
      - Europe/Prague
      - Europe/Riga
      - Europe/Rome
      - Europe/Samara
      - Europe/Saratov
      - Europe/Simferopol
      - Europe/Sofia
      - Europe/Stockholm
      - Europe/Tallinn
      - Europe/Tirane
      - Europe/Ulyanovsk
      - Europe/Uzhgorod
      - Europe/Vienna
      - Europe/Vilnius
      - Europe/Volgograd
      - Europe/Warsaw
      - Europe/Zaporozhye
      - Europe/Zurich
      - HST
      - Indian/Chagos
      - Indian/Christmas
      - Indian/Cocos
      - Indian/Kerguelen
      - Indian/Mahe
      - Indian/Maldives
      - Indian/Mauritius
      - Indian/Reunion
      - MET
      - MST
      - MST7MDT
      - PST8PDT
      - Pacific/Apia
      - Pacific/Auckland
      - Pacific/Bougainville
      - Pacific/Chatham
      - Pacific/Chuuk
      - Pacific/Easter
      - Pacific/Efate
      - Pacific/Enderbury
      - Pacific/Fakaofo
      - Pacific/Fiji
      - Pacific/Funafuti
      - Pacific/Galapagos
      - Pacific/Gambier
      - Pacific/Guadalcanal
      - Pacific/Guam
      - Pacific/Honolulu
      - Pacific/Kiritimati
      - Pacific/Kosrae
      - Pacific/Kwajalein
      - Pacific/Majuro
      - Pacific/Marquesas
      - Pacific/Nauru
      - Pacific/Niue
      - Pacific/Norfolk
      - Pacific/Noumea
      - Pacific/Pago_Pago
      - Pacific/Palau
      - Pacific/Pitcairn
      - Pacific/Pohnpei
      - Pacific/Port_Moresby
      - Pacific/Rarotonga
      - Pacific/Tahiti
      - Pacific/Tarawa
      - Pacific/Tongatapu
      - Pacific/Wake
      - Pacific/Wallis
      - WET
  password:
    Description: >-
      Enter a password for the username "admin". The password must be aligned
      with the Cisco ISE password policy (must contain one or more lowercase, uppercase, numeric, and non-alphanumeric characters). The configured password is used for
      Cisco ISE GUI access. Warning: The password is displayed in plaintext in
      the User Data section of the Instance settings window in the AWS Console.
    NoEcho: 'True'
    Type: String
    Default: 'Test123'
    AllowedPattern: >-
      ^(?=.*?[A-Z])(?=.*?[a-z])(?i)(?!.*?admin|.*?cisco|.*?nimda|.*?ocsic)(?-i)(?=.*?[0-9]).{6,}$
    ConstraintDescription: >-
      Password constraints: One digit is required. One uppercase letter. One
      lowercase letter. Password should not be the same as username(admin).
      Should not contain the word cisco. Minimum password length should be 6
      character.
  StorageSize:
    Description: >-
      Specify the storage in GB (Minimum 300GB and Maximum 2400GB). 600GB is
      recommended for production use, storage lesser than 600GB can be used for
      evaluation purpose only. On terminating the instance, volume will be
      deleted as well.
    Type: Number
    Default: '600'
    MinValue: '300'
    MaxValue: '2400'
    ConstraintDescription: >-
      Specify the storage in GB (Minimum 300GB and Maximum 2400GB). 600GB is
      recommended for production use, storage lesser than 600GB can be used for
      evaluation purpose only. On terminating the instance, volume will be
      deleted as well.
  VPCID:
    Description: 'ID of the VPC (e.g., vpc-0343606e)'
    Type: 'AWS::EC2::VPC::Id'
  VPCCIDR:
    AllowedPattern: '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(1[6-9]|2[0-8]))$'
    ConstraintDescription: CIDR block parameter must be in the form x.x.x.x/16-28
    Default: 10.0.0.0/16
    Description: CIDR block for the VPC.
    Type: String
  QSS3BucketName:
    AllowedPattern: "^[0-9a-zA-Z]+([0-9a-zA-Z-]*[0-9a-zA-Z])*$"
    ConstraintDescription: "Quick Start bucket name can include numbers, lowercase letters, uppercase letters, and hyphens (-). It cannot start or end with a hyphen (-)."
    Default: aws-quickstart
    Description: "S3 bucket name for the Quick Start assets. Quick Start bucket name can include numbers, lowercase letters, uppercase letters, and hyphens (-). It cannot start or end with a hyphen (-)."
    Type: String
  QSS3BucketRegion:
    Default: us-east-1
    Description: 'The AWS Region where the Quick Start S3 bucket (QSS3BucketName) is hosted. When using your own bucket, you must specify this value.'
    Type: String
  QSS3KeyPrefix:
    AllowedPattern: "^[0-9a-zA-Z-/]*$"
    ConstraintDescription: "Quick Start key prefix can include numbers, lowercase letters, uppercase letters, hyphens (-), and forward slash (/)."
    Default: quickstart-cisco-ise-on-aws/
    Description: "S3 key prefix for the Quick Start assets. Quick Start key prefix can include numbers, lowercase letters, uppercase letters, hyphens (-), and forward slash (/)."
    Type: String
  EmailSubscription:
    Default: vesivaku@cisco.com
    Description: 'Email list which will be notified about the Deployment health and Failover status'
    Type: String

Conditions:
  UsingDefaultBucket: !Equals [!Ref QSS3BucketName, 'aws-quickstart']
Mappings:
  CiscoISE31AMI:
    us-east-1:
      BYOL: ami-0bb0a9d243824a077
    us-east-2:
      BYOL: ami-0262130ee7b27f122
    us-west-1:
      BYOL: ami-0965fef2e601ad4d0
    us-west-2:
      BYOL: ami-0ffd69a117dbcbb9e
    ca-central-1:
      BYOL: ami-0715d661908b3c937
    eu-central-1:
      BYOL: ami-0526fe132f57b4dd5
    eu-west-1:
      BYOL: ami-0c0078c6bc939b794
    eu-west-2:
      BYOL: ami-0a0e17dd5fa1643e9
    eu-west-3:
      BYOL: ami-0f766d122c0b5c7b1
    eu-north-1:
      BYOL: ami-06d5092c5d2de909d
    ap-southeast-1:
      BYOL: ami-0214a475ff692424f
    ap-southeast-2:
      BYOL: ami-0f1846c9d911d1727
    ap-south-1:
      BYOL: ami-0add11be4e3a2b72e
    ap-northeast-1:
      BYOL: ami-0da69493a00c3ebb1
    ap-northeast-2:
      BYOL: ami-0a56667a39f884c9e
    sa-east-1:
      BYOL: ami-0feeceb6d1a0dd691
Resources:
  ISESecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: Enable HTTP, HTTPS and SSH to the ISE Server
      SecurityGroupIngress:
        - IpProtocol: -1
          Description: "Allow Internal traffic"
          CidrIp: !Ref VPCCIDR
      VpcId: !Ref VPCID

  IseLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub ${AWS::StackName}-00_ISE_cluster_launch_template
      LaunchTemplateData:
        InstanceType: !Ref ISEInstanceType
        KeyName: !Ref KeyPairName
        ImageId: !FindInMap
          - CiscoISE31AMI
          - !Ref 'AWS::Region'
          - BYOL
        BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeType: gp2
            DeleteOnTermination: 'true'
            Encrypted: !Ref EBSEncrypt
            VolumeSize: !Ref StorageSize
        SecurityGroupIds:
          - !Ref ISESecurityGroup
        TagSpecifications:
          -
            ResourceType: 'instance'
            Tags:
              - Key: "Name"
                Value: "ISENode"
  ISENode1:
    Type: 'AWS::EC2::Instance'
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref IseLaunchTemplate
        Version: !GetAtt 'IseLaunchTemplate.LatestVersionNumber'
      SubnetId: !Ref PrivateSubnet1A
      Tags:
        - Key: "Testnode"
          Value: "isenode01"
      UserData: !Base64
          'Fn::Join':
            - ''
            - - hostname=
              - !Ref Node1Hostname
              - |+

              - dnsdomain=
              - !Ref DNSDomain
              - |+

              - primarynameserver=169.254.169.253
              - |+

              - ntpserver=169.254.169.123
              - |+

              - username=admin
              - |+

              - password=
              - !Ref password
              - |+

              - timezone=
              - !Ref TimeZone
              - |+

              - ersapi=
              - !Ref ERSapi
              - |+

              - openapi=
              - !Ref OpenAPI
              - |+

              - pxGrid=
              - !Ref PXGrid
              - |+

              - pxgrid_cloud=
              - !Ref PXGridCloud
              - |+
  ISENode2:
    Type: 'AWS::EC2::Instance'
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref IseLaunchTemplate
        Version: !GetAtt 'IseLaunchTemplate.LatestVersionNumber'
      SubnetId: !Ref PrivateSubnet1B
      Tags:
        - Key: "Testnode"
          Value: "isenode02"
      UserData: !Base64
          'Fn::Join':
            - ''
            - - hostname=
              - !Ref Node2Hostname
              - |+

              - dnsdomain=
              - !Ref DNSDomain
              - |+

              - primarynameserver=169.254.169.253
              - |+

              - ntpserver=169.254.169.123
              - |+

              - username=admin
              - |+

              - password=
              - !Ref password
              - |+

              - timezone=
              - !Ref TimeZone
              - |+

              - ersapi=
              - !Ref ERSapi
              - |+

              - openapi=
              - !Ref OpenAPI
              - |+

              - pxGrid=
              - !Ref PXGrid
              - |+

              - pxgrid_cloud=
              - !Ref PXGridCloud
              - |+

  #Route53 configuration
  ForwardDNS:
    Type: 'AWS::Route53::HostedZone'
    Properties:
      HostedZoneConfig:
        Comment: 'Private hosted forward zone for ISE'
      Name: !Ref DNSDomain
      VPCs:
        - VPCId: !Ref VPCID
          VPCRegion: !Sub ${AWS::Region}
      HostedZoneTags:
        - Key: 'Name'
          Value: !Sub
          - forwardzone-${DNSDomain}
          - DNSDomain: !Ref DNSDomain
  ReverseDNS:
    Type: 'AWS::Route53::HostedZone'
    Properties:
      HostedZoneConfig:
        Comment: 'Private hosted reverse zone for ISE'
      Name: !Join
        - "."
        - - !Select [1, !Split ['.', !Ref VPCCIDR]]
          - !Select [0, !Split ['.', !Ref VPCCIDR]]
          - 'in-addr.arpa'
      VPCs:
        - VPCId: !Ref VPCID
          VPCRegion: !Sub ${AWS::Region}
      HostedZoneTags:
        - Key: 'Name'
          Value: !Sub
          - reversezone-${DNSDomain}
          - DNSDomain: !Ref DNSDomain
  ISEForwardDNSRecords:
    Type: AWS::Route53::RecordSetGroup
    Properties:
      Comment: Create records for Route53 hosted forward zone
      HostedZoneId: !Ref ForwardDNS
      RecordSets:
      - Name: !Join
          - "."
          - - !Ref Node1Hostname
            - !Ref DNSDomain
        ResourceRecords:
          - !GetAtt ISENode1.PrivateIp



        Type: A
        TTL: "300"
      - Name: !Join
          - "."
          - - !Ref Node2Hostname
            - !Ref DNSDomain
        ResourceRecords:
          - !GetAtt ISENode2.PrivateIp


        Type: A
        TTL: "300"
  ISEReverseDNSRecordNode1:
    Type: AWS::Route53::RecordSet
    Properties:
      Comment: Create records for Route53 hosted reverse zone for ise node 1
      HostedZoneId: !Ref ReverseDNS
      Name: !Join
        - "."
        - - !Select [3, !Split ['.', !GetAtt ISENode1.PrivateIp]]
          - !Select [2, !Split ['.', !GetAtt ISENode1.PrivateIp]]
          - !Select [1, !Split ['.', !GetAtt ISENode1.PrivateIp]]
          - !Select [0, !Split ['.', !GetAtt ISENode1.PrivateIp]]
          - 'in-addr.arpa'
      ResourceRecords:
        - !Join [
          ".",
          [!Ref Node1Hostname, !Ref DNSDomain]
        ]
      Type: PTR
      TTL: "300"
  ISEReverseDNSRecordNode2:
    Type: AWS::Route53::RecordSet
    Properties:
      Comment: Create records for Route53 hosted reverse zone for ise node 2
      HostedZoneId: !Ref ReverseDNS
      Name: !Join
        - "."
        - - !Select [3, !Split ['.', !GetAtt ISENode2.PrivateIp]]
          - !Select [2, !Split ['.', !GetAtt ISENode2.PrivateIp]]
          - !Select [1, !Split ['.', !GetAtt ISENode2.PrivateIp]]
          - !Select [0, !Split ['.', !GetAtt ISENode2.PrivateIp]]
          - 'in-addr.arpa'
      ResourceRecords:
        - !Join [
          ".",
          [!Ref Node2Hostname, !Ref DNSDomain]
        ]
      Type: PTR
      TTL: "300"
  LBDNSRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      Type: A
      Name: !Join
        - "."
        - - "lb"
          - !Ref DNSDomain
      AliasTarget:
        HostedZoneId: !GetAtt PSNNLB.CanonicalHostedZoneID
        DNSName: !GetAtt PSNNLB.DNSName
      HostedZoneId: !Ref ForwardDNS
  #load balancer resources
  PSNNLB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Type: network
      Scheme: internal
      IpAddressType: ipv4
      SubnetMappings:
      - SubnetId: !Ref PrivateSubnet1A
        PrivateIPv4Address: !Join
          - "."
          - - !Select [0, !Split ['.', !Ref PrivateSubnet1CIDR]]
            - !Select [1, !Split ['.', !Ref PrivateSubnet1CIDR]]
            - !Select [2, !Split ['.', !Ref PrivateSubnet1CIDR]]
            - '4'
      - SubnetId: !Ref PrivateSubnet1B
        PrivateIPv4Address: !Join
          - "."
          - - !Select [0, !Split ['.', !Ref PrivateSubnet2CIDR]]
            - !Select [1, !Split ['.', !Ref PrivateSubnet2CIDR]]
            - !Select [2, !Split ['.', !Ref PrivateSubnet2CIDR]]
            - '4'
      LoadBalancerAttributes:
        - Key: load_balancing.cross_zone.enabled
          Value: "true"
      Tags:
      - Key: Name
        Value: !Sub ${VPCID}-Nlb
  PSNTargetGroupforRADIUS1812:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckPort: '443'
      HealthCheckProtocol: TCP
      Port: 1812
      Protocol: UDP
      Targets:
      - Id: !Ref ISENode1
      - Id: !Ref ISENode2
      VpcId: !Ref VPCID
      Tags:
        - Key: "Name"
          Value: Radius1812
  PSNTargetGroupforRADIUS1813:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckPort: '443'
      HealthCheckProtocol: TCP
      Port: 1813
      Protocol: UDP
      Targets:
      - Id: !Ref ISENode1
      - Id: !Ref ISENode2
      VpcId: !Ref VPCID
      Tags:
        - Key: "Name"
          Value: Radius1813
  PSNTargetGroupforTACACS49:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckPort: '443'
      HealthCheckProtocol: TCP
      Port: 49
      Protocol: TCP
      Targets:
      - Id: !Ref ISENode1
      - Id: !Ref ISENode2
      VpcId: !Ref VPCID
      Tags:
        - Key: "Name"
          Value: Tacacs49
  PSNListener1:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref PSNTargetGroupforRADIUS1812
      LoadBalancerArn: !Ref PSNNLB
      Port: 1645
      Protocol: UDP
  PSNListener2:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref PSNTargetGroupforRADIUS1813
      LoadBalancerArn: !Ref PSNNLB
      Port: 1646
      Protocol: UDP
  PSNListener3:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref PSNTargetGroupforTACACS49
      LoadBalancerArn: !Ref PSNNLB
      Port: 49
      Protocol: TCP
  #lambda boilerplate
  CopyLambdaStack:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL:
        !Sub
          - https://${S3Bucket}.s3.${S3Region}.${AWS::URLSuffix}/${QSS3KeyPrefix}templates/copy-lambdas.yaml
          - S3Region: !If [UsingDefaultBucket, !Ref 'AWS::Region', !Ref QSS3BucketRegion]
            S3Bucket: !If [UsingDefaultBucket, !Sub '${QSS3BucketName}-${AWS::Region}', !Ref QSS3BucketName]
      Parameters:
        QSS3BucketName: !Ref QSS3BucketName
        QSS3KeyPrefix: !Ref QSS3KeyPrefix

  NotifyCiscoAdminTopic:
   Type: AWS::SNS::Topic
   Properties:
     DisplayName: NotifyCiscoAdminTopic
     Subscription:
       - Endpoint: !Ref EmailSubscription
         Protocol: "email"
     TopicName: NotifyCiscoAdminTopic

  # #cloudwatch alarms
  # ISENode1AutorecoverAlarm:
  #   Type: AWS::CloudWatch::Alarm
  #   Properties:
  #     AlarmActions:
  #       - !Sub arn:aws:automate:${AWS::Region}:ec2:recover
  #     AlarmDescription: Recover instance if its status checks fail.
  #     Namespace: AWS/EC2
  #     MetricName: StatusCheckFailed_System
  #     Dimensions:
  #       - Name: InstanceId
  #         Value: !Ref ISENode1
  #     EvaluationPeriods: 2
  #     Period: 60
  #     Statistic: Minimum
  #     ComparisonOperator: GreaterThanThreshold
  #     Threshold: 0
  # ISENode2AutorecoverAlarm:
  #   Type: AWS::CloudWatch::Alarm
  #   Properties:
  #     AlarmActions:
  #       - !Sub arn:aws:automate:${AWS::Region}:ec2:recover
  #     AlarmDescription: Recover instance if its status checks fail.
  #     Namespace: AWS/EC2
  #     MetricName: StatusCheckFailed_System
  #     Dimensions:
  #       - Name: InstanceId
  #         Value: !Ref ISENode2
  #     EvaluationPeriods: 2
  #     Period: 60
  #     Statistic: Minimum
  #     ComparisonOperator: GreaterThanThreshold
  #     Threshold: 0
  # Set up ISE Deployment resources
  ISEDeployment:
    Type: Custom::ISEDeployment
    DependsOn:
    - DeploymentStateMachine
    Properties:
      ServiceToken: !GetAtt DeploymentStateMachineLambda.Arn
      WaitHandle: !Ref DeploymentWaitHandle
  DeploymentStateMachineLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Invokes Lambda that kicks off deployment state machine
      Handler: index.handler
      Runtime: python3.6
      Role: !GetAtt DeploymentStateMachineLambdaRole.Arn
      Timeout: 300
      Code:
        ZipFile: !Sub |
          import boto3
          import json
          import logging
          import threading
          import cfnresponse
          sfn = boto3.client('stepfunctions')
          def timeout(event, context):
            logging.error('Execution is about to time out, sending failure response to CloudFormation')
            cfnresponse.send(event, context, cfnresponse.FAILED, {}, None)
          def handler(event, context):
            timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 0.5, timeout, args=[event, context])
            timer.start()
            logging.info('Received event: %s' % json.dumps(event))
            status = cfnresponse.SUCCESS
            responseData = {}
            try:
              if event['RequestType'] == 'Create':
                response = sfn.start_execution(
                  stateMachineArn='${DeploymentStateMachine}',
                  input=json.dumps(event)
                )
                responseData = {'executionArn': response['executionArn']}
              else:
                logging.info('Nothing to do')
            except Exception as e:
              logging.error('Exception: %s' % e, exc_info=True)
              status = cfnresponse.FAILED
            finally:
              timer.cancel()
              cfnresponse.send(event, context, status, responseData)




  ISENode2FqdnParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Description: FQDN of Secondary PAN
      Name: Secondary_FQDN
      Type: String
      Value: !Join [".",[!Ref Node2Hostname, !Ref DNSDomain]]
  SyncStatusParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Description: Sync status of deployment
      Name: SyncStatus
      Type: String
      Value: PENDING

  MaintenanceParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Description: Set this parameter to True for Maintenance
      Name: Maintenance
      Type: String
      Value: False

  DeploymentStateMachineLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - states:StartExecution
            Resource: "*"
  DeploymentStateMachine:
    Type: AWS::StepFunctions::StateMachine
    DependsOn:
    - CheckISEStatusLambda
    - SetPrimaryPANLambda
    - RegisterSecondaryNodeLambda
    - CheckSyncStatusLambda
    - CallbackLambda
    Properties:
      RoleArn: !GetAtt StatesExecutionRole.Arn
      DefinitionString: !Sub |-
        {
          "Comment": "A state machine that performs ISE nodes deployment.",
          "StartAt": "Explicit Wait for ISE boot start",
          "States": {
            "Explicit Wait for ISE boot start": {
              "Type": "Wait",
              "Seconds": 1500,
              "Next": "Wait for ISE to come up"
            },
            "Check ISE status": {
              "Type": "Task",
              "Resource": "${CheckISEStatusLambda.Arn}",
              "Next": "If ISE is up and running",
              "InputPath": "$",
              "ResultPath": "$.taskresult"
            },
            "If ISE is up and running": {
              "Type": "Choice",
              "Choices": [
                {
                  "And": [
                    {
                      "Variable": "$.taskresult.IseState",
                      "StringEquals": "pending"
                    },
                    {
                      "Variable": "$.taskresult.retries",
                      "StringEquals": "0"
                    }
                  ],
                  "Next": "ISE instance is not running"
                },
                {
                  "Variable": "$.taskresult.IseState",
                  "StringEquals": "running",
                  "Next": "Set Primary PAN"
                }
              ],
              "Default": "Wait for ISE to come up",
              "InputPath": "$"
            },
            "Wait for ISE to come up": {
              "Type": "Wait",
              "Seconds": 180,
              "Next": "Check ISE status"
            },
            "Set Primary PAN": {
              "Type": "Task",
              "Resource": "${SetPrimaryPANLambda.Arn}",
              "InputPath": "$",
              "Next": "Register Secondary Node",
              "Catch": [
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "Next": "Fail: Error Occured"
                }
              ],
              "ResultPath": "$.taskresult"
            },
            "Register Secondary Node": {
              "Type": "Task",
              "Resource": "${RegisterSecondaryNodeLambda.Arn}",
              "InputPath": "$",
              "Next": "Wait for Sync to complete",
              "Catch": [
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "Next": "Fail: Error Occured"
                }
              ],
              "ResultPath": "$.taskresult"
            },
            "Wait for Sync to complete": {
              "Type": "Wait",
              "Seconds": 240,
              "Next": "Check Sync status"
            },
            "Check Sync status": {
              "Type": "Task",
              "Resource": "${CheckSyncStatusLambda.Arn}",
              "InputPath": "$",
              "Next": "Is Sync complete?",
              "ResultPath": "$.taskresult"
            },
            "Is Sync complete?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.taskresult.SyncStatus",
                  "StringEquals": "SYNC_COMPLETED",
                  "Next": "Send Cfn Response"
                },
                {
                  "And": [
                    {
                      "Variable": "$.taskresult.SyncStatus",
                      "StringEquals": "SYNC_INPROGRESS"
                    },
                    {
                      "Variable": "$.taskresult.retries",
                      "StringEquals": "0"
                    }
                  ],
                  "Next": "Secondary node Sync failed"
                },
                {
                  "Variable": "$.taskresult.SyncStatus",
                  "StringEquals": "SYNC_FAILED",
                  "Next": "Secondary node Sync failed"
                }
              ],
              "Default": "Wait for Sync to complete",
              "InputPath": "$"
            },
            "Send Cfn Response": {
              "Type": "Task",
              "Resource": "${CallbackLambda.Arn}",
              "InputPath": "$",
              "Retry": [
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2
                }
              ],
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": [
                    "States.ALL"
                  ],
                  "Next": "Fail: Error Occured"
                }
              ]
            },
            "Fail: Error Occured": {
              "Type": "Fail"
            },
            "Secondary node Sync failed": {
              "Type": "Fail"
            },
            "ISE instance is not running": {
              "Type": "Fail"
            }
          }
        }
  StatesExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - !Sub states.${AWS::Region}.amazonaws.com
            Action:
              - "sts:AssumeRole"
  StatesExecutionPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: StatesExecutionPolicy
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: ["lambda:InvokeFunction", "sns:publish"]
            Resource: "*"
      Roles:
        - !Ref StatesExecutionRole

  # Set up Wait Condition for State Machine
  DeploymentWaitHandle:
    Type: AWS::CloudFormation::WaitConditionHandle
  DeploymentWaitCondition:
    Type: AWS::CloudFormation::WaitCondition
    DependsOn: ISEDeployment
    Properties:
      Count: 1
      Handle: !Ref DeploymentWaitHandle
      Timeout: 7200

  CheckISEStatusLambda:
    Type: AWS::Lambda::Function
    Properties:
      Timeout: 300
      Code:
        ZipFile: !Sub |
          import json
          import logging
          import threading
          import time
          from botocore.vendored import requests
          import boto3
          import sys
          import os
          import socket

          logging.basicConfig(stream = sys.stdout)
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def get_ssm_parameter(ssm_client, ssm_parameter_name,WithDecryption=False):
                  param_value = ssm_client.get_parameter(
                  Name=ssm_parameter_name,
                  WithDecryption=False
              )

                  return param_value.get('Parameter').get('Value')
          def set_ssm_parameter(ssm_client, ssm_parameter_name, value, Overwrite=True, Type="String"):
                  response = ssm_client.put_parameter(
                  Name=ssm_parameter_name,
                  Value=value,
                  Overwrite=True,
                  Type="String"
              )

                  return response

          def timeout(event, context):
                  logging.error('Execution is about to time out, sending failure response to CloudFormation')
                  requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='ISENodeStates',Data='failed due to timeout')).encode('utf-8')
                  response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                  sys.exit(1)

          def handler(event, context):
              runtime_region = os.environ['AWS_REGION']
              ssm_client = boto3.client('ssm',region_name=runtime_region)
              timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 0.5, timeout, args=[event, context])
              try:

                  isenode01_ip = socket.gethostbyname_ex('iseserver1.example.com')[2][-1]
                  isenode02_ip = socket.gethostbyname_ex('iseserver2.example.com')[2][-1]
                  logger.info("Installed ISE Instance IPs are:\n PPAN - {} , SPAN - {}".format(isenode01_ip, isenode02_ip))

                  logger.info("#Setting SSM parameters...")
                  set_ssm_parameter(ssm_client,"PPAN_IP",isenode01_ip)
                  set_ssm_parameter(ssm_client,"SPAN_IP",isenode02_ip)
                  set_ssm_parameter(ssm_client,"ADMIN_USERNAME","admin")
                  set_ssm_parameter(ssm_client,"ADMIN_PASSWORD","Test123",Type="SecureString")


                  logger.info("#Retriving SSM parameters...")
                  PPAN_IP = get_ssm_parameter(ssm_client,"PPAN_IP")
                  SPAN_IP = get_ssm_parameter(ssm_client,"SPAN_IP")
                  ADMIN_USERNAME = get_ssm_parameter(ssm_client,"ADMIN_USERNAME")
                  ADMIN_PASSWORD = get_ssm_parameter(ssm_client,"ADMIN_PASSWORD",WithDecryption=True)
                  API_AUTH = (ADMIN_USERNAME, ADMIN_PASSWORD)
                  API_HEADER = {'Content-Type': 'application/json', 'Accept': 'application/json'}
                  Secondary_FQDN = get_ssm_parameter(ssm_client,"Secondary_FQDN")

                  logger.info("Primmary Polcy Administration node ip : {}".format(PPAN_IP))
                  logger.info("Secondary Polcy Administration node ip : {}".format(SPAN_IP))
                  logger.info("ADMIN_USERNAME : {}".format(ADMIN_USERNAME))
                  logger.info("API_AUTH : {}".format(API_AUTH))
                  logger.info("API_HEADER : {}".format(API_HEADER))
                  logger.info("Secondary Polcy Administration node fqdn : {}".format(Secondary_FQDN))
                  data = {}
                  nodes_to_check = [PPAN_IP, SPAN_IP]
                  nodes_list = [PPAN_IP, SPAN_IP]
                  retries = 5
                  if "taskresult" in event:
                      retries = int(event['taskresult']['retries'])
                  for ip in nodes_to_check:
                      url = 'https://{}/api/v1/deployment/node'.format(ip)
                      try:
                          resp = requests.get(url, headers=API_HEADER, auth=API_AUTH, data=json.dumps(data), verify=False)
                          logger.info("API response for {} is {} ".format(ip, resp.text))
                          if resp.status_code == 200:
                              nodes_list.remove(ip)
                              logger.info("ISE - {} is up and running".format(ip))

                      except Exception as e:
                          logging.error('Exception: %s' % e, exc_info=True)
                          logger.error("Exception occured while executing get node details api for {}".format(ip))
                          retries -= 1
                          return {
                                  "IseState": "pending",
                                  "retries": str(retries)
                                  }

                  if nodes_list:
                    timer.cancel()
                    retries -= 1
                    return {
                              "IseState": "pending",
                              "retries": str(retries)
                            }
                  else:
                    timer.cancel()
                    return {
                              "IseState": "running",
                              "retries": "0"
                            }

              except Exception as e:
                logging.error('Exception: %s' % e, exc_info=True)



      Handler: index.handler
      Role: !GetAtt CheckISEStatusExecutionRole.Arn
      Runtime: python3.6
      VpcConfig:
        SecurityGroupIds:
          - !Ref ISESecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1A
          - !Ref PrivateSubnet1B
  CheckISEStatusExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
              - ec2:DescribeInstance
              - ec2:CreateNetworkInterface
            Resource: !Sub arn:${AWS::Partition}:ec2:*:*:*

  # Lambda - Sets one node to Primary PAN
  SetPrimaryPANLambda:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: !Sub |
          import json
          import logging
          import threading
          import time
          from botocore.vendored import requests
          import boto3
          import sys
          import os


          logging.basicConfig(stream = sys.stdout)
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          class PromoteToPrimaryFailed(Exception):
            """Raised when the Set Primary PAN Lambda is failed"""
            pass


          def get_ssm_parameter(ssm_client, ssm_parameter_name,WithDecryption=False):
                  param_value = ssm_client.get_parameter(
                  Name=ssm_parameter_name,
                  WithDecryption=False
              )

                  return param_value.get('Parameter').get('Value')

          def timeout(event, context):
                  logging.error('Execution is about to time out, sending failure response to CloudFormation')
                  requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='ISENodeStates',Data='failed due to timeout')).encode('utf-8')
                  response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                  sys.exit(1)


          def handler(event, context):

            runtime_region = os.environ['AWS_REGION']
            ssm_client = boto3.client('ssm',region_name=runtime_region)
            timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 0.5, timeout, args=[event, context])
            logger.info("#Retriving SSM parameters...")
            PPAN_IP = get_ssm_parameter(ssm_client,"PPAN_IP")
            SPAN_IP = get_ssm_parameter(ssm_client,"SPAN_IP")
            ADMIN_USERNAME = get_ssm_parameter(ssm_client,"ADMIN_USERNAME")
            ADMIN_PASSWORD = get_ssm_parameter(ssm_client,"ADMIN_PASSWORD",WithDecryption=True)
            API_AUTH = (ADMIN_USERNAME, ADMIN_PASSWORD)
            API_HEADER = {'Content-Type': 'application/json', 'Accept': 'application/json'}

            logger.info("Primmary Polcy Administration node ip : {}".format(PPAN_IP))
            logger.info("Secondary Polcy Administration node ip : {}".format(SPAN_IP))
            logger.info("ADMIN_USERNAME : {}".format(ADMIN_USERNAME))
            logger.info("API_AUTH : {}".format(API_AUTH))
            logger.info("API_HEADER : {}".format(API_HEADER))

            try:
              url = 'https://{}/api/v1/deployment/primary'.format(PPAN_IP)
              data = {}
              resp = requests.post(url, headers=API_HEADER, auth=API_AUTH, data=json.dumps(data), verify=False)

              logger.info("API Response is : {}".format(resp))
              if resp.status_code == 200:
                  logger.info("##### Standalone to Primary Successful on {} #####".format(PPAN_IP))
                  timer.cancel()
                  return {
                            "task_status": "Done"
                          }
              raise PromoteToPrimaryFailed({"Setting ISE Node to Primary Failed"})

            except Exception as e:
              requests_data=json.dumps(dict(Status='FAILURE',Reason='Setting ISE Node to Primary Failed',UniqueId='ISENodeStates',Data='exception')).encode('utf-8')
              response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
              logger.info(response)
              logging.error('Exception: %s' % e, exc_info=True)
              timer.cancel()



      Handler: index.handler
      Role: !GetAtt SetPrimaryPANLambdaExecutionRole.Arn
      Runtime: python3.6
      Timeout: 300
      VpcConfig:
        SecurityGroupIds:
          - !Ref ISESecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1A
          - !Ref PrivateSubnet1B
  SetPrimaryPANLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
              - ec2:DescribeInstance
              - ec2:CreateNetworkInterface
            Resource: !Sub arn:${AWS::Partition}:ec2:*:*:*

  RegisterSecondaryNodeLambda:
    Type: AWS::Lambda::Function
    Properties:
      Timeout: 300
      Code:
        ZipFile: !Sub |
          import json
          import logging
          import threading
          import time
          from botocore.vendored import requests
          import boto3
          import sys
          import os


          logging.basicConfig(stream = sys.stdout)
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          class RegisterSecondaryNodeFailed(Exception):
            """Raised when the Set Primary PAN Lambda is failed"""
            pass


          def get_ssm_parameter(ssm_client, ssm_parameter_name,WithDecryption=False):
                  param_value = ssm_client.get_parameter(
                  Name=ssm_parameter_name,
                  WithDecryption=False
              )

                  return param_value.get('Parameter').get('Value')

          def timeout(event, context):
                  logging.error('Execution is about to time out, sending failure response to CloudFormation')
                  requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='ISENodeStates',Data='failed due to timeout')).encode('utf-8')
                  response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                  sys.exit(1)

          def handler(event, context):
              runtime_region = os.environ['AWS_REGION']
              ssm_client = boto3.client('ssm',region_name=runtime_region)
              timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 0.5, timeout, args=[event, context])
              logger.info("#Retriving SSM parameters...")
              PPAN_IP = get_ssm_parameter(ssm_client,"PPAN_IP")
              SPAN_IP = get_ssm_parameter(ssm_client,"SPAN_IP")
              Secondary_FQDN = get_ssm_parameter(ssm_client,"Secondary_FQDN")
              ADMIN_USERNAME = get_ssm_parameter(ssm_client,"ADMIN_USERNAME")
              ADMIN_PASSWORD = get_ssm_parameter(ssm_client,"ADMIN_PASSWORD",WithDecryption=True)
              API_AUTH = (ADMIN_USERNAME, ADMIN_PASSWORD)
              API_HEADER = {'Content-Type': 'application/json', 'Accept': 'application/json'}

              logger.info("Primmary Polcy Administration node ip : {}".format(PPAN_IP))
              logger.info("Secondary Polcy Administration node ip : {}".format(SPAN_IP))
              logger.info("ADMIN_USERNAME : {}".format(ADMIN_USERNAME))
              logger.info("API_AUTH : {}".format(API_AUTH))
              logger.info("API_HEADER : {}".format(API_HEADER))
              logger.info("# Register Secondary node to deployment - start...")
              try:
                roles_enabled = ["SecondaryAdmin","SecondaryMonitoring"]
                service_enabled = ["Session", "Profiler"]

                url = 'https://{}/api/v1/deployment/node'.format(PPAN_IP)
                data = {"allowCertImport": True,
                        "fqdn": Secondary_FQDN,
                        "userName": ADMIN_USERNAME,
                        "password": ADMIN_PASSWORD,
                        "roles": roles_enabled,
                        "services": service_enabled,
                        }
                logger.info('Url: {}, Data: {}'.format(url, data))

                resp = requests.post(url, headers=API_HEADER, auth=API_AUTH, data=json.dumps(data), verify=False)
                logger.info('Register secondary response: {}, {}'.format(resp.status_code, resp.text))
                if resp.status_code == 200:
                    logger.info("Register Secondary node is successfull, API response is {}".format(resp.text))
                    timer.cancel()
                    return {
                            "task_status": "Done"
                          }
                raise RegisterSecondaryNodeFailed({"Register Secondary node to form deployment Failed"})


              except RegisterSecondaryNodeFailed:
                requests_data=json.dumps(dict(Status='FAILURE',Reason='Secondary Node Registration Failed',UniqueId='ISENodeStates',Data='exception')).encode('utf-8')
                response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                logger.info(response)
                timer.cancel()
                logging.error('Exception: %s', exc_info=True)


              except Exception as e:
                requests_data=json.dumps(dict(Status='FAILURE',Reason='Secondary Node Registration Failed',UniqueId='ISENodeStates',Data='exception')).encode('utf-8')
                response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                logger.info(response)
                timer.cancel()
                logging.error('Exception: %s' % e, exc_info=True)


      Handler: index.handler
      Role: !GetAtt RegisterSecondaryNodeExecutionRole.Arn
      Runtime: python3.6
      VpcConfig:
        SecurityGroupIds:
          - !Ref ISESecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1A
          - !Ref PrivateSubnet1B
  RegisterSecondaryNodeExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
              - ec2:DescribeInstance
              - ec2:CreateNetworkInterface
            Resource: !Sub arn:${AWS::Partition}:ec2:*:*:*
  # Lambda - Describes Primary PAN status. In this case, used for starting and stopping instances

  CheckSyncStatusLambda:
    Type: AWS::Lambda::Function
    Properties:
      Timeout: 300
      Code:
        ZipFile: !Sub |
          import json
          import logging
          import threading
          import time
          from botocore.vendored import requests
          import boto3
          import sys
          import os


          logging.basicConfig(stream = sys.stdout)
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def get_ssm_parameter(ssm_client, ssm_parameter_name,WithDecryption=False):
                  param_value = ssm_client.get_parameter(
                  Name=ssm_parameter_name,
                  WithDecryption=False
              )

                  return param_value.get('Parameter').get('Value')

          def set_ssm_parameter(ssm_client, ssm_parameter_name, value, Overwrite=True, Type="String"):
                  response = ssm_client.put_parameter(
                  Name=ssm_parameter_name,
                  Value=value,
                  Overwrite=True,
                  Type="String"
              )

                  return response

          def timeout(event, context):
                  logging.error('Execution is about to time out, sending failure response to CloudFormation')
                  requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='ISENodeStates',Data='failed due to timeout')).encode('utf-8')
                  response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                  sys.exit(1)

          def handler(event, context):
              timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 0.5, timeout, args=[event, context])
              runtime_region = os.environ['AWS_REGION']
              ssm_client = boto3.client('ssm',region_name=runtime_region)
              try:
                  logger.info("#Retriving SSM parameters...")
                  PPAN_IP = get_ssm_parameter(ssm_client,"PPAN_IP")
                  ADMIN_USERNAME = get_ssm_parameter(ssm_client,"ADMIN_USERNAME")
                  ADMIN_PASSWORD = get_ssm_parameter(ssm_client,"ADMIN_PASSWORD",WithDecryption=True)
                  API_AUTH = (ADMIN_USERNAME, ADMIN_PASSWORD)
                  API_HEADER = {'Content-Type': 'application/json', 'Accept': 'application/json'}

                  logger.info("Primmary Polcy Administration node ip : {}".format(PPAN_IP))
                  logger.info("ADMIN_USERNAME : {}".format(ADMIN_USERNAME))
                  logger.info("API_AUTH : {}".format(API_AUTH))
                  logger.info("API_HEADER : {}".format(API_HEADER))

                  data = {}
                  retries = 5
                  if "taskresult" in event:
                      retries = int(event['taskresult']['retries'])

                  url = 'https://{}/api/v1/deployment/node'.format(PPAN_IP)
                  try:
                      resp = requests.get(url, headers=API_HEADER, auth=API_AUTH, data=json.dumps(data), verify=False)
                      logger.info("API response for checking node sync status and roles is: {} ".format(resp.text))
                      if resp.status_code == 200:
                        json_resp = json.loads(resp.content.decode("utf-8"))

                        if json_resp["response"][0]['nodeStatus'] == "Connected" and json_resp["response"][1]['nodeStatus'] == "Connected":
                          set_ssm_parameter(ssm_client,"SyncStatus","SYNC_COMPLETED")
                          timer.cancel()
                          return {
                                    "SyncStatus": "SYNC_COMPLETED",
                                    "retries": "0"
                                  }
                        elif json_resp["response"][1]['nodeStatus'] == "RegistrationFailed":

                          set_ssm_parameter(ssm_client,"SyncStatus","SYNC_FAILED")
                          requests_data=json.dumps(dict(Status='FAILURE',Reason='Secondary Node Sync or Registration failed',UniqueId='ISENodeStates',Data='exception')).encode('utf-8')
                          response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                          logger.info(response)
                          timer.cancel()
                          return {
                                    "SyncStatus": "SYNC_FAILED",
                                    "retries": "0"
                                  }
                        else:
                          timer.cancel()
                          retries -= 1
                          return {
                                    "SyncStatus": "SYNC_INPROGRESS",
                                    "retries": str(retries)
                                  }

                  except Exception as e:
                      logging.error('Exception: %s' % e, exc_info=True)
                      logger.info("Exception occured while executing get node details api for {}".format(PPAN_IP))
                      timer.cancel()
                      retries -= 1
                      return {
                                "SyncStatus": "SYNC_INPROGRESS",
                                "retries": str(retries)
                              }

              except Exception as e:
                timer.cancel()
                logging.error('Exception: %s' % e, exc_info=True)
                retries -= 1
                return {
                          "SyncStatus": "SYNC_INPROGRESS",
                          "retries": str(retries)
                        }

      Handler: index.handler
      Role: !GetAtt CheckSyncStatusExecutionRole.Arn
      Runtime: python3.6
      VpcConfig:
        SecurityGroupIds:
          - !Ref ISESecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1A
          - !Ref PrivateSubnet1B
  CheckSyncStatusExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
              - ec2:DescribeInstance
              - ec2:CreateNetworkInterface
            Resource: !Sub arn:${AWS::Partition}:ec2:*:*:*

  # Lambda - Sends Callback to the CloudFormation Wait Condition, signaling whether the Deployment was created successfully
  CallbackLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Sends callback to CloudFormation to continue
      Code:
        ZipFile: |
          import json
          import logging
          import threading
          from botocore.vendored import requests
          import sys
          import boto3
          import os

          logging.basicConfig(stream = sys.stdout)
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)


          def timeout(event, context):
                  logging.error('Execution is about to time out, sending failure response to CloudFormation')
                  requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='ISENodeStates',Data='failed due to timeout')).encode('utf-8')
                  response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                  sys.exit(1)


          def get_ssm_parameter(ssm_client, ssm_parameter_name):
                  param_value = ssm_client.get_parameter(
                  Name=ssm_parameter_name,
                  WithDecryption=False
              )
                  return param_value.get('Parameter').get('Value')

          def handler(event, context):
              timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 2, timeout, args=[event, context])
              timer.start()
              logger.info('Received event: %s' % json.dumps(event))
              logger.info(event['ResourceProperties']['WaitHandle'])
              runtime_region = os.environ['AWS_REGION']
              ssm_client = boto3.client('ssm',region_name=runtime_region)
              try:
                logger.info("#Retriving SSM parameters...")
                SYNC_STATUS = get_ssm_parameter(ssm_client,"SyncStatus")
                if SYNC_STATUS == 'SYNC_COMPLETED':
                  logger.info("Sync is successful")
                  requests_data=json.dumps(dict(Status='SUCCESS',Reason='Deployment creation successful',UniqueId='ISENodeStates',Data='success')).encode('utf-8')
                else:
                  logger.info("Sync failed")
                  requests_data=json.dumps(dict(Status='FAILURE',Reason='Invalid Deployment Status',UniqueId='ISENodeStates',Data='failure')).encode('utf-8')
                response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                logger.info(response)
                timer.cancel()
              except Exception as e:
                logger.info("Sync failed")
                logging.error('Exception: %s' % e, exc_info=True)
                requests_data=json.dumps(dict(Status='FAILURE',Reason='Exception: %s' % e,UniqueId='ISENodeStates',Data='exception')).encode('utf-8')
                response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                logger.info(response)
                timer.cancel()

      Handler: index.handler
      Runtime: python3.6
      Role: !GetAtt CallbackRole.Arn
      Timeout: 300
  CallbackRole:

    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
              - ec2:DescribeInstance
              - ec2:CreateNetworkInterface
            Resource: !Sub arn:${AWS::Partition}:ec2:*:*:*

  #The lambda needs to be written. Trigger needs to be defined
  TriggerFailoverLambdaExecutionRole:

    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      - arn:aws:iam::aws:policy/AWSStepFunctionsFullAccess
      - arn:aws:iam::aws:policy/AmazonSNSFullAccess
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
              - ec2:DescribeInstance
              - ec2:CreateNetworkInterface

            Resource: !Sub arn:${AWS::Partition}:ec2:*:*:*

  TriggerFailoverLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Triggers Failover when Primary PAN is down
      Timeout: 300
      Role: !GetAtt 'TriggerFailoverLambdaExecutionRole.Arn'
      Handler: index.handler
      Runtime: python3.6
      Code:
        ZipFile: !Sub |
          import json
          import logging
          import threading
          import time
          from botocore.vendored import requests
          import boto3
          import sys
          import os
          logging.basicConfig(stream = sys.stdout)
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
            def get_ssm_parameter(ssm_client, ssm_parameter_name):
                param_value = ssm_client.get_parameter(
                Name=ssm_parameter_name,
                WithDecryption=False
            )

                return param_value.get('Parameter').get('Value')

            def set_ssm_parameter(ssm_client, ssm_parameter_name, value, Overwrite=True, Type="String"):
                response = ssm_client.put_parameter(
                Name=ssm_parameter_name,
                Value=value,
                Overwrite=True,
                Type="String"
            )

                return response

            def send_sns_publish(subject, message):
                client = boto3.client('sns')
                TopicArn = [item["TopicArn"] for item in client.list_topics()['Topics'] if "NotifyCiscoAdminTopic" in item["TopicArn"]]
                logger.info("Sending SNS publish..")
                response = client.publish(
                    Subject= subject,
                    Message= message,
                    TopicArn= TopicArn[0]
                    )

            runtime_region = os.environ['AWS_REGION']

            ssm_client = boto3.client('ssm',region_name=runtime_region)
            try:
                logger.info("#Retriving SSM parameters...")
                PPAN_IP = get_ssm_parameter(ssm_client,"PPAN_IP")
                SPAN_IP = get_ssm_parameter(ssm_client,"SPAN_IP")
                SyncStatus = get_ssm_parameter(ssm_client,"SyncStatus")
                ADMIN_USERNAME = get_ssm_parameter(ssm_client,"ADMIN_USERNAME")
                ADMIN_PASSWORD = get_ssm_parameter(ssm_client,"ADMIN_PASSWORD")
                API_AUTH = (ADMIN_USERNAME, ADMIN_PASSWORD)
                API_HEADER = {'Content-Type': 'application/json', 'Accept': 'application/json'}
                retries = 5
                Maintenance = get_ssm_parameter(ssm_client,"Maintenance")
                logger.info("Primmary Polcy Administration node ip : {}".format(PPAN_IP))
                logger.info("Secondary Polcy Administration node ip : {}".format(SPAN_IP))
                logger.info("ADMIN_USERNAME : {}".format(ADMIN_USERNAME))
                logger.info("API_AUTH : {}".format(API_AUTH))
                logger.info("API_HEADER : {}".format(API_HEADER))
                logger.info("Retries : {}".format(retries))
                node_status = ["NotApplicable", "NotInSync", "NotUpgraded", "RegistrationFailed", "ReplicationStopped"]
                data = {}
                if not bool(json.loads(Maintenance.lower())):

                    if SyncStatus == "SYNC_INPROGRESS":
                        logger.info("Sync status is {}", SyncStatus)
                        logger.info("Application still being deployed. Failover not required!")
                        return "skip"

                    elif SyncStatus == "SYNC_COMPLETED":

                        stepFunction = boto3.client('stepfunctions')
                        response = stepFunction.list_state_machines(
                                maxResults=123
                            )
                        response = response['stateMachines']
                        failover_state_machine_Arn = ""
                        for item in response:
                            logger.debug("Identifying Failover statemachine Arn")
                            if "FailoverStateMachine" in item['stateMachineArn']:
                                logger.debug("FailoverStateMachine Arn : {}".format(item['stateMachineArn']))
                                failover_state_machine_Arn = item['stateMachineArn']
                        logger.info("Triggering state machine with arn {}".format(failover_state_machine_Arn))
                        response = stepFunction.start_execution(
                                stateMachineArn=failover_state_machine_Arn
                            )

                    else:
                        logger.info("Need not execute Failover state machine. Sync status is unknown.")
                        return "skip"


            except Exception as e:
              logging.error('Exception: %s' % e, exc_info=True)


      MemorySize: 3008
      VpcConfig:
        SecurityGroupIds:
          - !Ref ISESecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1A
          - !Ref PrivateSubnet1B

  FailoverLambdaSchedulePermission:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Sub ${TriggerFailoverLambda.Arn}
      Principal: 'events.amazonaws.com'
      SourceArn: !Sub ${FailoverLambdaSchedule.Arn}
    DependsOn:
      - FailoverLambdaSchedule
  FailoverLambdaSchedule:
    Type: "AWS::Events::Rule"
    Properties:
      Description: >
        A schedule for the Failover Lambda function..
      ScheduleExpression: !Ref FailoverPollingRate
      State: ENABLED
      Targets:
        - Arn: !Sub ${TriggerFailoverLambda.Arn}
          Id: FailoverLambdaSchedule
    DependsOn:
      - TriggerFailoverLambda
      - DeploymentStateMachine

  HealthCheckLambdaSchedulePermission:
    Type: "AWS::Lambda::Permission"
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Sub ${HealthCheckLambda.Arn}
      Principal: 'events.amazonaws.com'
      SourceArn: !Sub ${HealthCheckLambdaSchedule.Arn}
    DependsOn:
      - HealthCheckLambdaSchedule

  HealthCheckLambdaSchedule:
    Type: "AWS::Events::Rule"
    Properties:
      Description: >
        A schedule for the Health check Lambda function..
      ScheduleExpression: !Ref HealthcheckPollingRate
      State: ENABLED
      Targets:
        - Arn: !Sub ${HealthCheckLambda.Arn}
          Id: HealthCheckLambdaSchedule
    DependsOn:
      - HealthCheckLambda
      - DeploymentStateMachine

  HealthCheckLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      - arn:aws:iam::aws:policy/AmazonSNSFullAccess

      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
              - ec2:DescribeInstance
              - ec2:CreateNetworkInterface

            Resource: !Sub arn:${AWS::Partition}:ec2:*:*:*

  HealthCheckLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Monitors the deployment and modifies Sync status in SSM parameter store
      Timeout: 300
      Role: !GetAtt 'HealthCheckLambdaExecutionRole.Arn'
      Handler: index.handler
      Runtime: python3.6
      Code:
        ZipFile: !Sub |
          import json
          import logging
          import threading
          import time
          from botocore.vendored import requests
          import boto3
          import sys
          import os
          logging.basicConfig(stream = sys.stdout)
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
              def get_ssm_parameter(ssm_client, ssm_parameter_name):
                  param_value = ssm_client.get_parameter(
                  Name=ssm_parameter_name,
                  WithDecryption=False
              )

                  return param_value.get('Parameter').get('Value')

              def set_ssm_parameter(ssm_client, ssm_parameter_name, value, Overwrite=True, Type="String"):
                  response = ssm_client.put_parameter(
                  Name=ssm_parameter_name,
                  Value=value,
                  Overwrite=True,
                  Type="String"
              )

                  return response

              def send_sns_publish(subject, message):
                  client = boto3.client('sns')
                  TopicArn = [item["TopicArn"] for item in client.list_topics()['Topics'] if "NotifyCiscoAdminTopic" in item["TopicArn"]]
                  logger.info("Sending SNS publish..")
                  response = client.publish(
                      Subject= subject,
                      Message= message,
                      TopicArn= TopicArn[0]
                      )

              runtime_region = os.environ['AWS_REGION']

              ssm_client = boto3.client('ssm',region_name=runtime_region)
              try:
                  logger.info("#Retriving SSM parameters...")
                  PPAN_IP = get_ssm_parameter(ssm_client,"PPAN_IP")
                  SPAN_IP = get_ssm_parameter(ssm_client,"SPAN_IP")
                  SyncStatus = get_ssm_parameter(ssm_client,"SyncStatus")
                  ADMIN_USERNAME = get_ssm_parameter(ssm_client,"ADMIN_USERNAME")
                  ADMIN_PASSWORD = get_ssm_parameter(ssm_client,"ADMIN_PASSWORD")
                  API_AUTH = (ADMIN_USERNAME, ADMIN_PASSWORD)
                  API_HEADER = {'Content-Type': 'application/json', 'Accept': 'application/json'}
                  retries = 5
                  Maintenance = get_ssm_parameter(ssm_client,"Maintenance")
                  logger.info("Primmary Polcy Administration node ip : {}".format(PPAN_IP))
                  logger.info("Secondary Polcy Administration node ip : {}".format(SPAN_IP))
                  logger.info("ADMIN_USERNAME : {}".format(ADMIN_USERNAME))
                  logger.info("API_AUTH : {}".format(API_AUTH))
                  logger.info("API_HEADER : {}".format(API_HEADER))
                  logger.info("Retries : {}".format(retries))
                  node_status = ["NotApplicable", "NotInSync", "NotUpgraded", "RegistrationFailed", "ReplicationStopped"]
                  data = {}
                  url = 'https://{}/api/v1/deployment/node'.format(PPAN_IP)
                  resp = requests.get(url, headers=API_HEADER, auth=API_AUTH, data=json.dumps(data), verify=False)
                  logger.info("API response for checking node sync status and roles is: {} ".format(resp.text))
                  json_resp = json.loads(resp.text)
                  if not bool(json.loads(Maintenance.lower())):
                      if json_resp["response"][0]['nodeStatus'] == "Connected" and json_resp["response"][1]['nodeStatus'] == "Connected":
                          set_ssm_parameter(ssm_client,"SyncStatus","SYNC_COMPLETED")
                      else :
                          set_ssm_parameter(ssm_client,"SyncStatus","SYNC_FAILED")
                          send_sns_publish(subject="Deployment health check notification: Secondary Node is not in sync with Primary Node", message = "Secondary Node is not in sync with Primary Node.")
                  else:
                      send_sns_publish(subject="Deployment is in Maintenance", message = "Deployment Healthcheck is not performed, Please ensure Maintenance parameter is set to False once the maintenance is completed.")


              except Exception as e:
                logging.error('Exception: %s' % e, exc_info=True)


      MemorySize: 3008
      VpcConfig:
        SecurityGroupIds:
          - !Ref ISESecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1A
          - !Ref PrivateSubnet1B

  FailoverStateMachine:
    Type: AWS::StepFunctions::StateMachine
    DependsOn:
      - CheckSPANGatewayStatusLambda
      - PerformFailoverLambda
      - CheckFailoverSuccessfulLambda
      - DeploymentStateMachine
    Properties:
      RoleArn: !GetAtt StatesExecutionRole.Arn
      DefinitionString: !Sub |-
        {
          "Comment": "A state machine that performs Failover by promoting SPAN to PPAN.",
          "StartAt": "Check PPAN Status",
          "States": {
            "Check PPAN Status": {
              "Type": "Task",
              "Resource": "${CheckPPANStatusLambda.Arn}",
              "Next": "Choice-Trigger Failover?",
              "InputPath": "$",
              "OutputPath": "$"
            },
            "Choice-Trigger Failover?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.PrimaryState",
                  "StringEquals": "running",
                  "Next": "PPAN is healthy. Failover not required!"
                },
                {
                  "And": [
                    {
                      "Variable": "$.PrimaryState",
                      "StringEquals": "failed"
                    },
                    {
                      "Variable": "$.retries",
                      "StringEquals": "0"
                    }
                  ],
                  "Next": "Check SPAN Gateway status"
                }
              ],
              "Default": "Wait-Polling  for PPAN status",
              "InputPath": "$"
            },
            "Wait-Polling  for PPAN status": {
              "Type": "Wait",
              "Seconds": 20,
              "Next": "Check PPAN Status"
            },
            "Check SPAN Gateway status": {
              "Type": "Task",
              "Resource": "${CheckSPANGatewayStatusLambda.Arn}",
              "Next": "Choice - Is SPAN API Gateway enabled?",
              "ResultPath": "$.SecondaryState",
              "InputPath": "$"
            },
            "Perform Failover": {
              "Type": "Task",
              "Resource": "${PerformFailoverLambda.Arn}",
              "Next": "Wait for Promotion",
              "ResultPath": "$.PromotionStatus",
              "InputPath": "$",
              "Catch": [
                {
                  "ErrorEquals": [
                    "States.Timeout"
                  ],
                  "Next": "Wait for Promotion"
                }
              ],
              "TimeoutSeconds": 180
            },
            "Choice - Is SPAN API Gateway enabled?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.SecondaryState",
                  "StringEquals": "GatewayDown",
                  "Next": "SNSPublishGatewayDisabledDefault"
                },
                {
                  "Variable": "$.SecondaryState",
                  "StringEquals": "running",
                  "Next": "Perform Failover"
                }
              ],
              "Default": "SNSPublishGatewayDisabledDefault"
            },
            "SNSPublishGatewayDisabledDefault": {
              "Type": "Task",
              "Resource": "arn:aws:states:::sns:publish",
              "Parameters": {
                "Subject": "Update from Failover State machine",
                "Message": "SPAN Gateway is disabled. \nCannot proceed with failover",
                "TopicArn": "${NotifyCiscoAdminTopic}"
              },
              "Next": "SPAN Gateway is down!"
            },
            "SPAN Gateway is down!": {
              "Type": "Fail",
              "Error": "Please check the logs",
              "Cause": "Cannot proceed failover without SPAN Gateway"
            },
            "Check Failover Successful": {
              "Type": "Task",
              "Resource": "${CheckFailoverSuccessfulLambda.Arn}",
              "Next": "Choice - Is Failover successful?",
              "InputPath": "$",
              "OutputPath": "$"
            },
            "Wait for Promotion": {
              "Type": "Wait",
              "Next": "Check Failover Successful",
              "Seconds": 180
            },
            "Choice - Is Failover successful?": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.FailoverStatus",
                  "StringEquals": "success",
                  "Next": "SNSPublishFailoverSuccessful"
                },
                {
                  "And": [
                    {
                      "Variable": "$.FailoverStatus",
                      "StringEquals": "pending"
                    },
                    {
                      "Variable": "$.failure_retries",
                      "StringEquals": "1"
                    }
                  ],
                  "Next": "Wait for Promotion"
                },
                {
                  "Variable": "$.FailoverStatus",
                  "StringEquals": "failure",
                  "Next": "SNSPublishFailoverUnsuccessful"
                }
              ],
              "Default": "Wait for Promotion",
              "InputPath": "$"
            },
            "SNSPublishFailoverUnsuccessful": {
              "Type": "Task",
              "Resource": "arn:aws:states:::sns:publish",
              "Parameters": {
                "Subject": "Update from Failover State machine",
                "Message": "Failover is not successful!",
                "TopicArn": "${NotifyCiscoAdminTopic}"
              },
              "Next": "Failure is unsuccessful"
            },
            "SNSPublishFailoverSuccessful": {
              "Type": "Task",
              "Resource": "arn:aws:states:::sns:publish",
              "Parameters": {
                "Subject": "Update from Failover State machine",
                "Message": "Failover is successful!",
                "TopicArn": "${NotifyCiscoAdminTopic}"
              },
              "Next": "Failover Successful"
            },
            "Failure is unsuccessful": {
              "Type": "Fail",
              "Error": "Please check the new PPAN for more information"
            },
            "Failover Successful": {
              "Type": "Succeed"
            },
            "PPAN is healthy. Failover not required!": {
              "Type": "Succeed"
            }
          }
        }
  CheckPPANStatusLambda:
    Type: AWS::Lambda::Function
    Properties:
      Timeout: 300
      Code:
        ZipFile: !Sub |
          import json
          import logging
          import threading
          import time
          from botocore.vendored import requests
          import boto3
          import sys
          import os

          logging.basicConfig(stream = sys.stdout)
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
              def get_ssm_parameter(ssm_client, ssm_parameter_name):
                  param_value = ssm_client.get_parameter(
                  Name=ssm_parameter_name,
                  WithDecryption=False
              )

                  return param_value.get('Parameter').get('Value')

              def set_ssm_parameter(ssm_client, ssm_parameter_name, value, Overwrite=True, Type="String"):
                  response = ssm_client.put_parameter(
                  Name=ssm_parameter_name,
                  Value=value,
                  Overwrite=True,
                  Type="String"
              )

                  return response
              runtime_region = os.environ['AWS_REGION']
              ssm_client = boto3.client('ssm',region_name=runtime_region)
              try:
                  logger.info("#Retriving SSM parameters...")
                  PPAN_IP = get_ssm_parameter(ssm_client,"PPAN_IP")
                  SPAN_IP = get_ssm_parameter(ssm_client,"SPAN_IP")
                  SyncStatus = get_ssm_parameter(ssm_client,"SyncStatus")
                  ADMIN_USERNAME = get_ssm_parameter(ssm_client,"ADMIN_USERNAME")
                  ADMIN_PASSWORD = get_ssm_parameter(ssm_client,"ADMIN_PASSWORD")
                  API_AUTH = (ADMIN_USERNAME, ADMIN_PASSWORD)
                  API_HEADER = {'Content-Type': 'application/json', 'Accept': 'application/json'}
                  retries = 5
                  logger.info("Primmary Polcy Administration node ip : {}".format(PPAN_IP))
                  logger.info("Secondary Polcy Administration node ip : {}".format(SPAN_IP))
                  logger.info("ADMIN_USERNAME : {}".format(ADMIN_USERNAME))
                  logger.info("API_AUTH : {}".format(API_AUTH))
                  logger.info("API_HEADER : {}".format(API_HEADER))
                  logger.info("Retries : {}".format(retries))

                  data = {}

                  url = 'https://{}/api/v1/deployment/node'.format(PPAN_IP)
                  try:
                      resp = requests.get(url, headers=API_HEADER, auth=API_AUTH, data=json.dumps(data), verify=False)
                      logger.info("API response for {} is {} ".format(PPAN_IP, resp.text))
                      parse_resp = json.loads(resp.text)
                      hosts = parse_resp['response']
                      if resp.status_code == 200:
                          for item in hosts:
                              if "hostname" in item.keys():
                                  logger.info("ISE - {} is up and running".format(PPAN_IP))
                                  logger.info("Promotion not required")
                                  return {
                                  "PrimaryState": "running",
                                  "retries": "0"
                                      }
                      else:
                          raise RuntimeError('Failed to get successful response from PPAN')

                  except Exception as e:
                      logger.error("Exception occured while executing get node details api for {}".format(PPAN_IP))
                      logger.info("Promoting SPAN - {} to PPAN".format(SPAN_IP))

                      if "retries" in event:
                          retries = int(event['retries']) - 1
                          return {
                              "PrimaryState": "failed",
                              "retries": str(retries)
                              }
                      else:
                          return {
                              "PrimaryState": "failed",
                              "retries": str(retries)
                              }
                      logging.error('Exception: %s' % e, exc_info=True)


              except Exception as e:
                logging.error('Exception: %s' % e, exc_info=True)


      Handler: index.handler
      Role: !GetAtt CheckPPANStatusExecutionRole.Arn
      Runtime: python3.6
      VpcConfig:
        SecurityGroupIds:
          - !Ref ISESecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1A
          - !Ref PrivateSubnet1B

  CheckPPANStatusExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
              - ec2:DescribeInstance
              - ec2:CreateNetworkInterface
            Resource: !Sub arn:${AWS::Partition}:ec2:*:*:*

  CheckSPANGatewayStatusLambda:
    Type: AWS::Lambda::Function
    Properties:
      Timeout: 300
      Code:
        ZipFile: !Sub |
          import json
          import logging
          import threading
          import time
          from botocore.vendored import requests
          import boto3
          import sys
          import os

          logging.basicConfig(stream = sys.stdout)
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def get_ssm_parameter(ssm_client, ssm_parameter_name,WithDecryption=False):
                  param_value = ssm_client.get_parameter(
                  Name=ssm_parameter_name,
                  WithDecryption=False
              )

                  return param_value.get('Parameter').get('Value')

          def set_ssm_parameter(ssm_client, ssm_parameter_name, value, Overwrite=True, Type="String"):
                  response = ssm_client.put_parameter(
                  Name=ssm_parameter_name,
                  Value=value,
                  Overwrite=True,
                  Type="String"
              )

                  return response

          def timeout(event, context):
                  logging.error('Execution is about to time out, sending failure response to CloudFormation')
                  requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='ISENodeStates',Data='failed due to timeout')).encode('utf-8')
                  response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                  sys.exit(1)

          def handler(event, context):
              timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 0.5, timeout, args=[event, context])
              runtime_region = os.environ['AWS_REGION']
              ssm_client = boto3.client('ssm',region_name=runtime_region)
              try:
                  logger.info("#Retriving SSM parameters...")
                  PPAN_IP = get_ssm_parameter(ssm_client,"PPAN_IP")
                  SPAN_IP = get_ssm_parameter(ssm_client,"SPAN_IP")
                  SyncStatus = get_ssm_parameter(ssm_client,"SyncStatus")
                  ADMIN_USERNAME = get_ssm_parameter(ssm_client,"ADMIN_USERNAME")
                  ADMIN_PASSWORD = get_ssm_parameter(ssm_client,"ADMIN_PASSWORD")
                  API_AUTH = (ADMIN_USERNAME, ADMIN_PASSWORD)
                  API_HEADER = {'Content-Type': 'application/json', 'Accept': 'application/json'}

                  logging.info("Primmary Polcy Administration node ip : {}".format(PPAN_IP))
                  logging.info("Secondary Polcy Administration node ip : {}".format(SPAN_IP))
                  logging.info("ADMIN_USERNAME : {}".format(ADMIN_USERNAME))
                  logging.info("API_AUTH : {}".format(API_AUTH))
                  logging.info("API_HEADER : {}".format(API_HEADER))
                  logger.info("SyncStatus : {}".format(SyncStatus))
                  data = {}

                  url = 'https://{}/api/v1/deployment/node'.format(SPAN_IP)
                  try:
                      resp = requests.get(url, headers=API_HEADER, auth=API_AUTH, data=json.dumps(data), verify=False)
                      # logging.info("API response for {} is {} ".format(SPAN_IP, resp.text))
                      parse_resp = json.loads(resp.text)
                      hosts = parse_resp['response']
                      if resp.status_code == 200:
                          for item in hosts:
                              if "hostname" in item.keys():
                                  logging.info("SPAN - {} has API gateway enabled".format(SPAN_IP))
                                  timer.cancel()
                                  return "running"
                      else:
                          raise RuntimeError('Failed to get successful response from SPAN')
                  except Exception as e:
                      logger.error("Exception occured while executing get node details api for {}".format(SPAN_IP))
                      logger.error("API Gateway is not enabled".format(SPAN_IP))
                      logging.error('Exception: %s' % e, exc_info=True)
                      timer.cancel()
                      return "GatewayDown"

              except Exception as e:
                  timer.cancel()
                  logging.error('Exception: %s' % e, exc_info=True)



      Handler: index.handler
      Role: !GetAtt CheckSPANGatewayStatusExecutionRole.Arn
      Runtime: python3.6
      VpcConfig:
        SecurityGroupIds:
          - !Ref ISESecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1A
          - !Ref PrivateSubnet1B

  CheckSPANGatewayStatusExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
              - ec2:DescribeInstance
              - ec2:CreateNetworkInterface
            Resource: !Sub arn:${AWS::Partition}:ec2:*:*:*

  PerformFailoverLambda:
    Type: AWS::Lambda::Function
    Properties:
      Timeout: 180
      Code:
        ZipFile: !Sub |
          import json
          import logging
          import threading
          import time
          from botocore.vendored import requests
          import boto3
          import sys
          import os

          logging.basicConfig(stream = sys.stdout)
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def get_ssm_parameter(ssm_client, ssm_parameter_name,WithDecryption=False):
                  param_value = ssm_client.get_parameter(
                  Name=ssm_parameter_name,
                  WithDecryption=False
              )

                  return param_value.get('Parameter').get('Value')

          def set_ssm_parameter(ssm_client, ssm_parameter_name, value, Overwrite=True, Type="String"):
                  response = ssm_client.put_parameter(
                  Name=ssm_parameter_name,
                  Value=value,
                  Overwrite=True,
                  Type="String"
              )

                  return response

          def timeout(event, context):
                  logging.error('Execution is about to time out, sending failure response to CloudFormation')
                  requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='ISENodeStates',Data='failed due to timeout')).encode('utf-8')
                  response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                  sys.exit(1)

          def handler(event, context):
              timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 0.5, timeout, args=[event, context])
              runtime_region = os.environ['AWS_REGION']
              ssm_client = boto3.client('ssm',region_name=runtime_region)
              try:
                  logger.info("#Retriving SSM parameters...")
                  PPAN_IP = get_ssm_parameter(ssm_client,"PPAN_IP")
                  SPAN_IP = get_ssm_parameter(ssm_client,"SPAN_IP")
                  SyncStatus = get_ssm_parameter(ssm_client,"SyncStatus")
                  ADMIN_USERNAME = get_ssm_parameter(ssm_client,"ADMIN_USERNAME")
                  ADMIN_PASSWORD = get_ssm_parameter(ssm_client,"ADMIN_PASSWORD")
                  API_AUTH = (ADMIN_USERNAME, ADMIN_PASSWORD)
                  API_HEADER = {'Content-Type': 'application/json', 'Accept': 'application/json'}

                  logging.info("Primmary Polcy Administration node ip : {}".format(PPAN_IP))
                  logging.info("Secondary Polcy Administration node ip : {}".format(SPAN_IP))
                  logging.info("ADMIN_USERNAME : {}".format(ADMIN_USERNAME))
                  logging.info("API_AUTH : {}".format(API_AUTH))
                  logging.info("API_HEADER : {}".format(API_HEADER))

                  data = {}

                  url = 'https://{}/api/v1/deployment/promote'.format(SPAN_IP)
                  try:
                      resp = requests.post(url, headers=API_HEADER, auth=API_AUTH, data=json.dumps(data), verify=False)
                      logging.info("API response for {} is {} ".format(SPAN_IP, resp.text))
                      if resp.status_code == 200 and "success" in json.loads(resp.text):
                          logging.info("SPAN to PPAN Promotion successful for - {}".format(SPAN_IP))
                          timer.cancel()
                          return "running"
                      else:
                          raise RuntimeError('Failed to get promote SPAN to PPAN')
                  except Exception as e:
                      logging.error("Exception occured while promoting SPAN {}".format(SPAN_IP))
                      logging.error('Exception: %s' % e, exc_info=True)
                      timer.cancel()
                      return "down"

              except Exception as e:
                  timer.cancel()
                  logging.error('Exception: %s' % e, exc_info=True)


      Handler: index.handler
      Role: !GetAtt PerformFailoverExecutionRole.Arn
      Runtime: python3.6
      VpcConfig:
        SecurityGroupIds:
          - !Ref ISESecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1A
          - !Ref PrivateSubnet1B

  PerformFailoverExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
              - ec2:DescribeInstance
              - ec2:CreateNetworkInterface
            Resource: !Sub arn:${AWS::Partition}:ec2:*:*:*

  CheckFailoverSuccessfulLambda:
    Type: AWS::Lambda::Function
    Properties:
      Timeout: 300
      Code:
        ZipFile: !Sub |
          import json
          import logging
          import threading
          import time
          from botocore.vendored import requests
          import boto3
          import sys
          import os

          logging.basicConfig(stream = sys.stdout)
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def get_ssm_parameter(ssm_client, ssm_parameter_name,WithDecryption=False):
                  param_value = ssm_client.get_parameter(
                  Name=ssm_parameter_name,
                  WithDecryption=False
              )

                  return param_value.get('Parameter').get('Value')

          def set_ssm_parameter(ssm_client, ssm_parameter_name, value, Overwrite=True, Type="String"):
                  response = ssm_client.put_parameter(
                  Name=ssm_parameter_name,
                  Value=value,
                  Overwrite=True,
                  Type="String"
              )

                  return response

          def timeout(event, context):
                  logging.error('Execution is about to time out, sending failure response to CloudFormation')
                  requests_data=json.dumps(data=dict(Status='FAILURE',Reason='Lambda timeout',UniqueId='ISENodeStates',Data='failed due to timeout')).encode('utf-8')
                  response = requests.put(event['ResourceProperties']['WaitHandle'], data=requests_data, headers={'Content-Type':''})
                  sys.exit(1)

          def handler(event, context):
              timer = threading.Timer((context.get_remaining_time_in_millis() / 1000.00) - 0.5, timeout, args=[event, context])
              runtime_region = os.environ['AWS_REGION']
              ssm_client = boto3.client('ssm',region_name=runtime_region)
              try:
                  logging.info("#Retriving SSM parameters...")
                  PPAN_IP = get_ssm_parameter(ssm_client,"PPAN_IP")
                  SPAN_IP = get_ssm_parameter(ssm_client,"SPAN_IP")
                  SyncStatus = get_ssm_parameter(ssm_client,"SyncStatus")
                  ADMIN_USERNAME = get_ssm_parameter(ssm_client,"ADMIN_USERNAME")
                  ADMIN_PASSWORD = get_ssm_parameter(ssm_client,"ADMIN_PASSWORD")
                  API_AUTH = (ADMIN_USERNAME, ADMIN_PASSWORD)
                  API_HEADER = {'Content-Type': 'application/json', 'Accept': 'application/json'}
                  retries = 5
                  logging.info("Primmary Polcy Administration node ip : {}".format(PPAN_IP))
                  logging.info("Secondary Polcy Administration node ip : {}".format(SPAN_IP))
                  logging.info("ADMIN_USERNAME : {}".format(ADMIN_USERNAME))
                  logging.info("API_AUTH : {}".format(API_AUTH))
                  logging.info("API_HEADER : {}".format(API_HEADER))

                  data = {}

                  url = 'https://{}/api/v1/deployment/node'.format(SPAN_IP)
                  try:
                      resp = requests.get(url, headers=API_HEADER, auth=API_AUTH, data=json.dumps(data), verify=False)
                      logging.info("API response for {} is {} ".format(SPAN_IP, resp.text))
                      parse_resp = json.loads(resp.text)
                      hosts = parse_resp['response']
                      if resp.status_code == 200:
                          for item in hosts:
                              if "hostname" in item.keys():
                                  logging.info("Promotion is successful for {}".format(SPAN_IP))
                                  timer.cancel()
                                  logging.info("Updating SSM parameters for SPAN and PPAN")
                                  logging.info("Old PPAN = {} , SPAN = {}".format(PPAN_IP, SPAN_IP))
                                  set_ssm_parameter(ssm_client,"PPAN_IP", SPAN_IP)
                                  set_ssm_parameter(ssm_client,"SPAN_IP", PPAN_IP)
                                  PPAN_IP = get_ssm_parameter(ssm_client,"PPAN_IP")
                                  SPAN_IP = get_ssm_parameter(ssm_client,"SPAN_IP")
                                  logging.info("New PPAN = {} , SPAN = {}".format(PPAN_IP, SPAN_IP))
                                  return {
                                        "FailoverStatus": "success",
                                        "failover_retries": str(retries)
                                        }
                      else:
                          raise RuntimeError('Failed to get node details from new PPAN')
                  except Exception as e:
                      print("Exception occured while executing get node details api for {}".format(SPAN_IP))
                      if "failover_retries" in event:
                          retries = int(event['failover_retries'])
                          if retries == 0:
                              return {
                                "FailoverStatus": "failure"
                                }
                          else:
                              retries = int(event['failover_retries']) - 1
                              return {
                                "FailoverStatus": "pending",
                                "failover_retries": str(retries)
                                }
                      else:
                          return {
                            "FailoverStatus": "pending",
                            "failover_retries": str(retries)
                            }


              except Exception as e:
                  # timer.cancel()
                  logging.error('Exception: %s' % e, exc_info=True)




      Handler: index.handler
      Role: !GetAtt CheckFailoverSuccessfulExecutionRole.Arn
      Runtime: python3.6
      VpcConfig:
        SecurityGroupIds:
          - !Ref ISESecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1A
          - !Ref PrivateSubnet1B

  CheckFailoverSuccessfulExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      - arn:aws:iam::aws:policy/AmazonSSMFullAccess
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
              - ec2:DescribeInstance
              - ec2:CreateNetworkInterface
            Resource: !Sub arn:${AWS::Partition}:ec2:*:*:*


Outputs:
  ISENode1ID:
    Description: 'InstanceID of the newly created ISE Node 1 '
    Value: !Ref ISENode1
  ISENode1PrivateDnsName:
    Description: Private DNSName of the newly created ISE Node 1
    Value: !GetAtt 
      - ISENode1
      - PrivateDnsName
  ISENode1PrivateIp:
    Description: Private IP address of the newly created ISE Node 1
    Value: !GetAtt 
      - ISENode1
      - PrivateIp
  ISENode2ID:
    Description: 'InstanceID of the newly created ISE Node 2 '
    Value: !Ref ISENode2
  ISENode2PrivateDnsName:
    Description: Private DNSName of the newly created ISE Node 2
    Value: !GetAtt 
      - ISENode2
      - PrivateDnsName
  ISENode2PrivateIp:
    Description: Private IP address of the newly created ISE Node 2
    Value: !GetAtt 
      - ISENode2
      - PrivateIp